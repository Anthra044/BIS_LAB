import numpy as np
x_data = np.array([1, 2, 3, 4, 5])
y_data = np.array([3, 5, 7, 9, 11])
def objective_function(theta):
theta_0, theta_1 = theta
predictions = theta_0 + theta_1 * x_data
errors = y_data - predictions
return np.sum(errors**2)
num_particles = 30
num_iterations = 10
w = 0.7
c1 = 1.5
c2 = 2.1

bounds = [(-10, 10), (-10, 10)]
positions = np.array([np.random.uniform(low, high, num_particles) for low, high in bounds]).T
velocities = np.random.uniform(-1, 1, (num_particles, 2))
personal_best_positions = np.copy(positions)
personal_best_values = np.array([objective_function(p) for p in personal_best_positions])
best_particle_index = np.argmin(personal_best_values)
global_best_position = personal_best_positions[best_particle_index]
global_best_value = personal_best_values[best_particle_index]
for iteration in range(num_iterations):
for i in range(num_particles):
fitness = objective_function(positions[i])
if fitness &lt; personal_best_values[i]:
personal_best_values[i] = fitness
personal_best_positions[i] = positions[i]
if fitness &lt; global_best_value:
global_best_value = fitness
global_best_position = positions[i]
for i in range(num_particles):
r1 = np.random.rand(2)
r2 = np.random.rand(2)
cognitive = c1 * r1 * (personal_best_positions[i] - positions[i])
social = c2 * r2 * (global_best_position - positions[i])
velocities[i] = w * velocities[i] + cognitive + social
positions[i] += velocities[i]
for dim in range(2):
positions[i, dim] = np.clip(positions[i, dim], bounds[dim][0], bounds[dim][1])
print(f&quot;Iteration {iteration+1}/{num_iterations}, Best SSE: {global_best_value:.5f}&quot;)
print(&quot;\nBest parameters found:&quot;)
print(&quot;theta_0 =&quot;, global_best_position[0])
print(&quot;theta_1 =&quot;, global_best_position[1])
print(&quot;Minimum sum of squared errors:&quot;, global_best_value)
