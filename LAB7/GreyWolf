import numpy as np
def gwo(obj_func, dim, search_space, n_agents=20, max_iter=100):
lb, ub = search_space
wolves = np.random.uniform(lb, ub, (n_agents, dim))
alpha, beta, delta = None, None, None
alpha_score, beta_score, delta_score = float(&quot;inf&quot;), float(&quot;inf&quot;), float(&quot;inf&quot;)
for t in range(max_iter):
for i in range(n_agents):
fitness = obj_func(wolves[i])
if fitness &lt; alpha_score:
delta_score, delta = beta_score, beta
beta_score, beta = alpha_score, alpha
alpha_score, alpha = fitness, wolves[i].copy()

elif fitness &lt; beta_score:
delta_score, delta = beta_score, beta
beta_score, beta = fitness, wolves[i].copy()
elif fitness &lt; delta_score:
delta_score, delta = fitness, wolves[i].copy()
a = 2 - 2 * (t / max_iter)
for i in range(n_agents):
for j in range(dim):
r1, r2 = np.random.rand(), np.random.rand()
A1, C1 = 2 * a * r1 - a, 2 * r2
D_alpha = abs(C1 * alpha[j] - wolves[i][j])
X1 = alpha[j] - A1 * D_alpha
r1, r2 = np.random.rand(), np.random.rand()
A2, C2 = 2 * a * r1 - a, 2 * r2
D_beta = abs(C2 * beta[j] - wolves[i][j])
X2 = beta[j] - A2 * D_beta
r1, r2 = np.random.rand(), np.random.rand()
A3, C3 = 2 * a * r1 - a, 2 * r2
D_delta = abs(C3 * delta[j] - wolves[i][j])
X3 = delta[j] - A3 * D_delta
wolves[i][j] = np.clip((X1 + X2 + X3) / 3, lb, ub)
return alpha, alpha_score
grid_size = (20, 20)
start, goal = np.array([0, 0]), np.array([19, 19])
obstacles = [
(5, 5, 10, 10),
(12, 0, 14, 14),
(3, 15, 15, 17)
]
def is_collision(point):
x, y = point.astype(int)
if x &lt; 0 or y &lt; 0 or x &gt;= grid_size[0] or y &gt;= grid_size[1]:
return True
for ox1, oy1, ox2, oy2 in obstacles:
if ox1 &lt;= x &lt;= ox2 and oy1 &lt;= y &lt;= oy2:
return True
return False
waypoints = waypoints.reshape(-1, 2)
path = [start] + [w.astype(int) for w in waypoints] + [goal]
total_dist, penalty = 0, 0
for i in range(len(path) - 1):
dist = np.linalg.norm(path[i + 1] - path[i])
total_dist += dist
if is_collision(path[i + 1]):
penalty += 100
energy = 0
for i in range(1, len(path) - 1):
v1 = path[i] - path[i - 1]
v2 = path[i + 1] - path[i]

if np.linalg.norm(v1) &gt; 0 and np.linalg.norm(v2) &gt; 0:
cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
angle = np.arccos(np.clip(cos_angle, -1, 1))
energy += angle
return total_dist + energy * 5 + penalty
n_waypoints = 5 # intermediate waypoints
dim = n_waypoints * 2
best_path, best_score = gwo(path_cost, dim, (0, grid_size[0]-1), n_agents=30, max_iter=200)
best_waypoints = best_path.reshape(-1, 2).astype(int)
final_path = np.vstack([start, best_waypoints, goal])
clean_path = []
for p in final_path:
pt = tuple(map(int, p))
if len(clean_path) == 0 or pt != clean_path[-1]:
clean_path.append(pt)
print(&quot;Best Path Found:&quot;)
for p in clean_path:
print(p)
print(&quot;\nPath Cost:&quot;, round(best_score, 2))
