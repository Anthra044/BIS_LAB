import numpy as np
import random
from itertools import permutations
distance_matrix = np.array([
[0, 2, 9, 10],
[2, 0, 6, 4],
[9, 6, 0, 8],
[10, 4, 8, 0]
])
num_customers = distance_matrix.shape[0] - 1
population_size = 9
grid_dim = (3, 3)
num_vehicles = 2
def generate_individual():
perm = list(range(1, num_customers + 1))
random.shuffle(perm)
return perm
population = [generate_individual() for _ in range(population_size)]
def fitness(individual):
split_points = np.linspace(0, num_customers, num_vehicles + 1, dtype=int)
total_distance = 0
for i in range(num_vehicles):
route = [0] + individual[split_points[i]:split_points[i+1]] + [0] # depot at start and end
for j in range(len(route) - 1):
total_distance += distance_matrix[route[j], route[j+1]]
return total_distance
def get_neighbors(idx):
r, c = divmod(idx, grid_dim[1])
neighbors = []
for dr in [-1, 0, 1]:
for dc in [-1, 0, 1]:
nr, nc = r + dr, c + dc
if 0 &lt;= nr &lt; grid_dim[0] and 0 &lt;= nc &lt; grid_dim[1]:
n_idx = nr * grid_dim[1] + nc
if n_idx != idx:
neighbors.append(n_idx)
return neighbors
def crossover(parent1, parent2):
size = len(parent1)
a, b = sorted(random.sample(range(size), 2))
child = [None] * size
child[a:b] = parent1[a:b]
pointer = b
for gene in parent2[b:] + parent2[:b]:
if gene not in child:
if pointer == size:
pointer = 0
